<?php

namespace FOS\HttpCacheBundle\EventListener;

use FOS\HttpCacheBundle\CacheManager;
use FOS\HttpCacheBundle\Invalidator\InvalidatorCollection;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Event\PostResponseEvent;
use Symfony\Component\Routing\RouterInterface;

/**
 * On kernel.terminate event, this listener invalidates routes for the current request and flushes the cache manager
 *
 * @author David de Boer <david@driebit.nl>
 */
class InvalidationListener implements EventSubscriberInterface
{
    /**
     * Cache manager
     *
     * @var CacheManager
     */
    protected $cacheManager;

    /**
     * Invalidator collection
     *
     * @var InvalidatorCollection
     */
    protected $invalidators;

    /**
     * Router
     *
     * @var RouterInterface
     */
    protected $router;

    /**
     * Constructor
     *
     * @param CacheManager          $cacheManager
     * @param InvalidatorCollection $invalidators
     * @param RouterInterface       $router
     */
    public function __construct(
        CacheManager $cacheManager,
        InvalidatorCollection $invalidators,
        RouterInterface $router
    ) {
        $this->cacheManager = $cacheManager;
        $this->invalidators = $invalidators;
        $this->router = $router;
    }

    /**
     * Apply invalidators and flush cache manager
     *
     * On kernel.terminate:
     * - see if any invalidators apply to the current request and, if so, add
     *   their routes to the cache manager
     * - flush the cache manager in order to send invalidation requests to the
     *   HTTP cache.
     *
     * @param PostResponseEvent $event
     *
     * @return array Paths that were flushed from the invalidation queue
     */
    public function onKernelTerminate(PostResponseEvent $event)
    {
        // Are there any invalidators configured for the current request route?
        $request = $event->getRequest();
        $requestRoute = $request->attributes->get('_route');
        if (!$this->invalidators->hasInvalidatorRoute($requestRoute)) {
            return $this->cacheManager->flush();
        }

        // Don't invalidate any caches if the request was unsuccessful
        $response = $event->getResponse();
        if (!$response->isSuccessful()) {
            return $this->cacheManager->flush();
        }

        $requestParams = $request->attributes->get('_route_params');
        $invalidators = $this->invalidators->getInvalidators($requestRoute);
        foreach ($invalidators as $invalidator) {
            foreach ($invalidator->getInvalidatedRoutes() as $route => $config) {
                $path = $this->router->generate($route, $requestParams);

                // If extra route parameters should be ignored, strip the query
                // string generated by the Symfony router from the path
                if (isset($config['ignore_extra_params'])
                    && $config['ignore_extra_params']
                    && $pos = strpos($path, '?')
                ) {
                    $path = substr($path, 0, $pos);
                }

                $this->cacheManager->invalidatePath($path);
            }
        }

        return $this->cacheManager->flush();
    }

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedEvents()
    {
        return array(KernelEvents::TERMINATE => 'onKernelTerminate');
    }
}